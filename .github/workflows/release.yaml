name: Release
on:
  push:
    branches:
      - 'release-*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Assemble artifacts
        run: |
          echo Hello > hello.txt
          echo World > world.txt
          tar czvf release.tar.gz hello.txt world.txt
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release
          path: release.tar.gz
          retention-days: 5

  create-github-release:
    needs: build
    runs-on: ubuntu-latest
#    environment:
#      name: production
#      url: ${{ steps.create-github-release.outputs.release-html-url }}
    permissions:
      # Allows creating releases
      contents: write
    outputs:
      release-api-url: ${{ steps.create-github-release.outputs.release-api-url }}
      tag-name: ${{ steps.create-github-release.outputs.tag-name }}
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: release
      - name: Create GitHub Release
        id: create-github-release
        uses: actions/github-script@v6
        env:
          GH_TOKEN: ${{ secrets.github_token }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            function getVersionFromFile(filePath) {
                const content = fs.readFileSync(filePath, { encoding: "utf-8" });
                return {
                    major: parseInt(/^#define [A-Z_]+_VERSION_MAJOR (\d+$)/gm.exec(content)[1], 10),
                    minor: parseInt(/^#define [A-Z_]+_VERSION_MINOR (\d+$)/gm.exec(content)[1], 10),
                    patch: parseInt(/^#define [A-Z_]+_VERSION_PATCH (\d+$)/gm.exec(content)[1], 10),
                    preRelease: /^#define [A-Z_]+_VERSION_PRE_RELEASE "([^"]*)"$/gm.exec(content)[1],
                    buildMetadata: /^#define [A-Z_]+_VERSION_BUILD_METADATA "([^"]*)"$/gm.exec(content)[1]
                };
            }

            const filesToUpload = ["release.tar.gz"];
            const version = getVersionFromFile("version.h");
            const tagName = [
              [version.major, version.minor, version.patch].join("."),
              version.preRelease,
              version.buildMetadata
            ].join("");
            const target = context.sha;

            const releaseRes = await (async () => {
              try {
                return await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tagName,
                  target_commitish: target,
                  draft: true
                });
              } catch (e) {
                throw new Error("Failed to create release");
              }
            })();

            const release = releaseRes.data;
            core.setOutput("release-api-url", release.url);
            core.setOutput("release-html-url", release.html_url);
            core.setOutput("tag-name", tagName);

            for (const filePath of filesToUpload) {
              const fileName = path.basename(filePath);
              const fileSize = fs.statSync(filePath).size;
              const fileStream = fs.createReadStream(filePath);
              const assetRes = await (async () => {
                try {
                  return await github.request({
                    method: "POST",
                    url: release.upload_url,
                    headers: {
                      authorization: process.env.GH_TOKEN,
                      "content-length": fileSize
                    },
                    name: fileName,
                    data: fileStream
                  });
                } catch (e) {
                  throw new Error("Failed to upload release asset");
                }
              })();

              const asset = assetRes.data;
            }

            core.notice(`Please review and edit the release draft. Make no mistakeâ€”edit the draft, don't publish it.`, { title: "GitHub Release" });

  check-github-release:
    needs: create-github-release
    runs-on: ubuntu-latest
#    environment:
#      name: production
#      url: ${{ steps.check-github-release.outputs.release-html-url }}
    permissions:
      # Allows retrieving releases
      contents: write
    steps:
      - uses: actions/github-script@v6
        name: Check GitHub Release
        id: check-github-release
        env:
          GH_TOKEN: ${{ secrets.github_token }}
          RELEASE_API_URL: ${{ needs.create-github-release.outputs.release-api-url }}
          TAG_NAME: ${{ needs.create-github-release.outputs.tag-name }}
          TARGET_COMMIT: ${{ github.sha }}
        with:
          script: |
            const releaseApiUrl = process.env.RELEASE_API_URL;
            if (!releaseApiUrl) {
              throw new Error("Release API URL is missing");
            }

            const tagName = process.env.TAG_NAME;
            if (!tagName) {
              throw new Error("Tag name is missing");
            }
            const targetCommit = process.env.TARGET_COMMIT;
            if (!targetCommit) {
              throw new Error("Target commit is missing");
            }

            const releaseRes = await (async () => {
              try {
                return await github.rest.repos.getRelease({
                  url: releaseApiUrl
                });
              } catch (e) {
                throw new Error("Failed to get release");
              }
            })();

            const release = releaseRes.data;
            const currentTagName = release.tag_name;
            core.setOutput("release-html-url", release.html_url);

            if (currentTagName !== tagName) {
              core.error("Refrain from changing the tag of the release.", { title: "GitHub Release" });
              process.exit(1);
            }

            if (release.target_commitish !== targetCommit) {
              core.error("Refrain from changing the target commit.", { title: "GitHub Release" });
              process.exit(1);
            }

            if (release.draft !== true) {
              core.error("The release draft was supposed to be edited, not published.", { title: "GitHub Release" });
              process.exit(1);
            }

            const tagRefReq = await (async () => {
              try {
                return await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
              } catch (e) {
                core.error("Make sure to push the tag for the release.", { title: "GitHub Release" });
                process.exit(1);
              }
            })();

            const tagRef = tagRefReq.data;
            const tagUrl = tagRef.object.url;

            const tagRes = await (async () => {
              try {
                return await github.rest.git.getTag({
                  url: tagUrl
                });
              } catch (e) {
                throw new Error("Failed to retrieve the tag");
              }
            })();

            const tag = tagRes.data;

            if (tag.verification.verified !== true) {
              core.error("The tag assigned to the release must be verified by GitHub.", { title: "GitHub Release" });
              process.exit(1);
            }

            if (tag.object.sha !== targetCommit) {
              core.error("The tag assigned to the release points to the wrong commit.", { title: "GitHub Release" });
              process.exit(1);
            }

            core.notice(`The release meets my critera so I will defer to your judgment.`, { title: "GitHub Release" });

  publish-github-release:
    needs: [create-github-release, check-github-release]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.publish-github-release.outputs.release-html-url }}
    permissions:
      # Allows updating releases
      contents: write
    steps:
      - uses: actions/github-script@v6
        name: Publish GitHub Release
        id: publish-github-release
        env:
          GH_TOKEN: ${{ secrets.github_token }}
          RELEASE_API_URL: ${{ needs.create-github-release.outputs.release-api-url }}
        with:
          script: |
            const releaseApiUrl = process.env.RELEASE_API_URL;
            if (!releaseApiUrl) {
              throw new Error("Release API URL is missing");
            }

            const releaseRes = await (async () => {
              try {
                return await github.rest.repos.updateRelease({
                  url: releaseApiUrl,
                  draft: false
                });
              } catch (e) {
                throw new Error("Failed to update release");
              }
            })();

            const release = releaseRes.data;
            core.setOutput("release-html-url", release.html_url);
            core.notice(`The release has been published.`, { title: "GitHub Release" });

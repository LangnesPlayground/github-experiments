name: Release
on:
  push:
    branches:
      - 'release-*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Assemble artifacts
        run: |
          echo Hello > hello.txt
          echo World > world.txt
          tar czvf release.tar.gz hello.txt world.txt
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release
          path: release.tar.gz
          retention-days: 5
  create-github-release:
    needs: build
    runs-on: ubuntu-latest
#    environment:
#      name: production
#      url: ${{ steps.create-github-release.outputs.release-url }}
    permissions:
      # Allows creating a release
      contents: write
    outputs:
      release-url: ${{ steps.create-github-release.outputs.release-url }}
      auto-tag: ${{ steps.create-github-release.outputs.auto-tag }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: release
      - name: Create GitHub Release
        id: create-github-release
        uses: actions/github-script@v6
        env:
          GH_TOKEN: ${{ secrets.github_token }}
        with:
          script: |
            const fs = require("fs/promises");
            const path = require("path");
            const filesToUpload = ["release.tar.gz"];
            const autoTag = `auto-${context.runId}-${context.runNumber}`;
            const target = context.sha;
            const releaseRes = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: autoTag,
              target_commitish: target,
              draft: true
            });
            if (releaseRes.status !== 201) {
              throw new Error("Failed to create release");
            }
            const release = releaseRes.data;
            console.log(release);
            for (const filePath of filesToUpload) {
              const fileName = path.basename(filePath);
              const file = await fs.open(filePath);
              try {
                const assetRes = await github.request({
                  method: "POST",
                  url: release.upload_url,
                  headers: {
                    authorization: process.env.GH_TOKEN
                  },
                  name: fileName,
                  body: file.readableWebStream()
                });
                console.log(assetRes)
              } finally {
                file.close();
              }
            }
            /*for (const filePath of filesToUpload) {
              const uploadUrl = new URL(release.upload_url);
              const fileName = path.basename(filePath);
              const fileStream = fs.createReadStream(filePath);
              const assetRes = await fetch(uploadUrl, {
                method: "POST",
                headers: {
                  Authorization: process.env.GH_TOKEN,
                },
                body: fileStream
              });
              console.log(assetRes)
              const asset = assetRes.json();
              console.log(asset.json())
              if (assetRes.status !== 201) {
                throw new Error("Failed to upload asset");
              }
            }*/
#        run: |
#          files=(release.tar.gz)
#          build_id="${{ github.run_id }}-${{ github.run_attempt }}"
#          auto_tag="auto-${build_id}"
#
#          echo "auto-tag=${auto_tag}" >> "${GITHUB_OUTPUT}"
#
#          repo="${{ github.repository }}"
#          repo_owner="${repo%%/*}"
#          repo_name="${repo#*/}"
#
#          gh config set prompt disabled || exit 1
#          release_url=$(gh release --repo "${repo}" create \
#            --draft --target "${{ github.sha }}" "${auto_tag}" "${files[@]}") || exit 1
#          release_id=$(gh api graphql -f query="query { repository(owner: \"${repo_owner}\", name: \"${repo_name}\") { release(tagName: \"${auto_tag}\") { id tagName } } }" -q ".data.repository.release.id") || exit 1
#
#          echo "release-id=${release_id}" >> "${GITHUB_OUTPUT}"
#          echo "release-url=${release_url}" >> "${GITHUB_OUTPUT}"
#          echo "::notice title=GitHub Release::Please review and finish editing the release draft."
#  publish-github-release:
#    needs: create-github-release
#    runs-on: ubuntu-latest
#    environment:
#      name: production
#      url: ${{ needs.create-github-release.outputs.release-url }}
#    permissions:
#      # Allows updating a release
#      contents: write
#    steps:
#      - name: Publish GitHub Release
#        env:
#          GH_TOKEN: ${{ secrets.github_token }}
#        run: |
#          repo="${{ github.repository }}"
#          repo_owner="${repo%%/*}"
#          repo_name="${repo#*/}"
#
#          auto_tag="${{ needs.create-github-release.outputs.auto-tag }}"
#          if [[ -z "${auto_tag}" ]]; then
#            echo "::error title=GitHub Release::Auto tag is missing."
#            exit 1
#          fi
#
#          gh config set prompt disabled || exit 1
#
#          output=$(gh api graphql -f query="query { repository(owner: \"${repo_owner}\", name: \"${repo_name}\") { release(tagName: \"${auto_tag}\") { id } } }" -q '.data.repository.release.id') || exit 1
#          if [[ ! -z "${output}" ]]; then
#            echo "::error title=GitHub Release::Did you forget to update the tag of the release?"
#            exit 1
#          fi
#
#          gh release --repo "${repo}" view 0.1.0 --json tagName -q '.tagName'
#
#          if ! gh release --repo "${repo}" edit --verify-tag; then
#            echo "::error title=GitHub Release::Please make sure to push the tag for the release."
#            exit 1
#          fi

name: Release
on:
  push:
    branches:
      - 'release-*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Assemble artifacts
        run: |
          echo Hello > hello.txt
          echo World > world.txt
          tar czvf release.tar.gz hello.txt world.txt
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release
          path: release.tar.gz
          retention-days: 5

  create-github-release:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.create-github-release.outputs.release-url }}
    permissions:
      # Allows creating a release
      contents: write
    outputs:
      release-api-url: ${{ steps.create-github-release.outputs.release-api-url }}
      auto-tag: ${{ steps.create-github-release.outputs.auto-tag }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: release
      - name: Create GitHub Release
        id: create-github-release
        uses: actions/github-script@v6
        env:
          GH_TOKEN: ${{ secrets.github_token }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            const filesToUpload = ["release.tar.gz"];
            const autoTag = `auto-${context.runId}-${context.runNumber}`;
            const target = context.sha;

            const releaseRes = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: autoTag,
              target_commitish: target,
              draft: true
            });

            if (releaseRes.status !== 201) {
              throw new Error("Failed to create release");
            }

            const release = releaseRes.data;
            core.setOutput("release-api-url", release.url);
            core.setOutput("release-html-url", release.html_url);
            core.setOutput("auto-tag", autoTag);

            for (const filePath of filesToUpload) {
              const fileName = path.basename(filePath);
              const fileSize = fs.statSync(filePath).size;
              const fileStream = fs.createReadStream(filePath);
              const assetRes = await github.request({
                method: "POST",
                url: release.upload_url,
                headers: {
                  authorization: process.env.GH_TOKEN,
                  "content-length": fileSize
                },
                name: fileName,
                data: fileStream
              });

              if (assetRes.status !== 201) {
                throw new Error("Failed to upload release asset");
              }

              const asset = assetRes.data;
            }

            core.notice(`Please review and edit the release draft. Make no mistakeâ€”edit the draft, don't publish it.`, { title: "GitHub Release" });

  check-github-release:
    needs: create-github-release
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.check-github-release.outputs.release-html-url }}
    steps:
      - uses: actions/github-script@v6
        name: Check GitHub Release
        id: check-github-release
        env:
          GH_TOKEN: ${{ secrets.github_token }}
          RELEASE_API_URL: ${{ needs.create-github-release.outputs.release-api-url }}
          AUTO_TAG: ${{ needs.create-github-release.outputs.auto-tag }}
          TARGET_COMMIT: ${{ github.sha }}
        with:
          script: |
            const releaseApiUrl = process.env.RELEASE_API_URL;
            if (!releaseApiUrl) {
              throw new Error("Release API URL is missing");
            }

            const autoTag = process.env.AUTO_TAG;
            if (!autoTag) {
              throw new Error("Auto tag is missing");
            }
            const targetCommit = process.env.TARGET_COMMIT;
            if (!targetCommit) {
              throw new Error("Target commit is missing");
            }

            const releaseRes = await github.rest.repos.getRelease({
              url: releaseApiUrl
            });

            if (releaseRes.status !== 200) {
              throw new Error("Failed to get release");
            }

            const release = releaseRes.data;
            const tagName = release.tag_name;
            core.setOutput("release-html-url", release.html_url);

            if (tagName === autoTag) {
              core.error("It appears that the release still has the generated tag assigned to it. Did you forget to change the tag?", { title: "GitHub Release" });
              process.exit(1);
            }

            if (release.target_commitish !== targetCommit) {
              core.error("Refrain from changing the target commit.", { title: "GitHub Release" });
              process.exit(1);
            }

            if (release.draft !== true) {
              core.error("The release was supposed to be a draft but isn't anymore.", { title: "GitHub Release" });
              process.exit(1);
            }

            const tagRefReq = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${tagName}`
            });

            if (tagRefReq.status !== 200) {
              core.error("Make sure to push the tag for the release.", { title: "GitHub Release" });
              process.exit(1);
            }

            const tagRef = tagRefReq.data;
            const tagUrl = tagRef.object.url;

            const tagRes = await github.rest.git.getTag({
              url: tagUrl
            });

            const tag = tagRes.data;

            if (tag.verification.verified !== true) {
              core.error("The tag assigned to the release must be verified by GitHub.", { title: "GitHub Release" });
              process.exit(1);
            }

            if (tag.object.sha !== targetCommit) {
              core.error("The tag assigned to the release points to the wrong commit.", { title: "GitHub Release" });
              process.exit(1);
            }

            core.notice(`The release meets my critera so I will defer to your judgment.`, { title: "GitHub Release" });

  publish-github-release:
    needs: [create-github-release, check-github-release]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.publish-github-release.outputs.release-html-url }}
    permissions:
      # Allows updating a release
      contents: write
    steps:
      - uses: actions/github-script@v6
        name: Publish GitHub Release
        id: publish-github-release
        env:
          GH_TOKEN: ${{ secrets.github_token }}
          RELEASE_API_URL: ${{ needs.create-github-release.outputs.release-api-url }}
        with:
          script: |
            const releaseApiUrl = process.env.RELEASE_API_URL;
            if (!releaseApiUrl) {
              throw new Error("Release API URL is missing");
            }

            const releaseRes = await github.rest.repos.updateRelease({
              url: releaseApiUrl,
              draft: false
            });

            if (releaseRes.status !== 200) {
              throw new Error("Failed to update release");
            }

            const release = releaseRes.data;
            core.setOutput("release-html-url", release.html_url);
            core.notice(`The release has been published.`, { title: "GitHub Release" });

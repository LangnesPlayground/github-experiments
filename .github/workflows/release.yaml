name: Release
on:
  push:
    branches:
      - 'release-*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Assemble artifacts
        run: |
          echo Hello > hello.txt
          echo World > world.txt
          tar czvf release.tar.gz hello.txt world.txt
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release
          path: release.tar.gz
          retention-days: 5
  create-github-release:
    needs: build
    runs-on: ubuntu-latest
#    environment:
#      name: production
#      url: ${{ steps.create-github-release.outputs.release-url }}
    permissions:
      # Allows creating a release
      contents: write
    outputs:
      release-api-url: ${{ steps.create-github-release.outputs.release-api-url }}
      auto-tag: ${{ steps.create-github-release.outputs.auto-tag }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: release
      - name: Create GitHub Release
        id: create-github-release
        uses: actions/github-script@v6
        env:
          GH_TOKEN: ${{ secrets.github_token }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            const filesToUpload = ["release.tar.gz"];
            const autoTag = `auto-${context.runId}-${context.runNumber}`;
            const target = context.sha;

            const releaseRes = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: autoTag,
              target_commitish: target,
              draft: true
            });

            if (releaseRes.status !== 201) {
              throw new Error("Failed to create release");
            }

            const release = releaseRes.data;
            core.setOutput("release-api-url", release.url);
            core.setOutput("release-html-url", release.html_url);
            core.setOutput("auto-tag", autoTag);

            for (const filePath of filesToUpload) {
              const fileName = path.basename(filePath);
              const fileSize = fs.statSync(filePath).size;
              const fileStream = fs.createReadStream(filePath);
              const assetRes = await github.request({
                method: "POST",
                url: release.upload_url,
                headers: {
                  authorization: process.env.GH_TOKEN,
                  "content-length": fileSize
                },
                name: fileName,
                data: fileStream
              });

              if (assetRes.status !== 201) {
                throw new Error("Failed to upload release asset");
              }

              const asset = assetRes.data;
            }

            core.notice(`Please review and edit the release draft: ${release.html_url}`, { title: "GitHub Release" });

  publish-github-release:
    needs: create-github-release
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.publish-github-release.outputs.release-html-url }}
    permissions:
      # Allows updating a release
      contents: write
    steps:
      - uses: actions/github-script@v6
        name: Publish GitHub Release
        id: publish-github-release
        env:
          GH_TOKEN: ${{ secrets.github_token }}
          RELEASE_API_URL: ${{ needs.create-github-release.outputs.release-api-url }}
          AUTO_TAG: ${{ needs.create-github-release.outputs.auto-tag }}
          TARGET_COMMIT: ${{ github.sha }}
        with:
          script: |
            const releaseApiUrl = process.env.RELEASE_API_URL;
            if (!releaseApiUrl) {
              throw new Error("Release API URL is missing");
            }

            const autoTag = process.env.AUTO_TAG;
            if (!autoTag) {
              throw new Error("Auto tag is missing");
            }
            const targetCommit = process.env.TARGET_COMMIT;
            if (!targetCommit) {
              throw new Error("Target commit is missing");
            }

            const releaseRes = await github.rest.repos.getRelease({
              url: releaseApiUrl
            });

            if (releaseRes.status !== 200) {
              throw new Error("Failed to get release");
            }

            const release = releaseRes.data;
            const tagName = release.tag_name;
            core.setOutput("release-html-url", release.html_url);

            if (tagName === autoTag) {
              core.error("Did you forget to update the tag for the release?", { title: "GitHub Release" });
              throw new Error("Tag assigned to release is the same as the generated one");
            }

            if (release.target_commitish !== targetCommit) {
              core.error("Please refrain from changing the target commit.", { title: "GitHub Release" });
              throw new Error("Tag assigned to release was changed");
            }

            const tagRefReq = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${tagName}`
            });

            if (tagRefReq.status !== 200) {
              core.error("Please make sure to push the tag for the release.", { title: "GitHub Release" });
              throw new Error("Tag assigned to release was not found");
            }

            const tagRef = tagRefReq.data;
            const tagSha = tagRef.object.sha;
            const tagUrl = tagRef.object.url;

            const tagRes = await github.rest.git.getTag({
              url: tagUrl
            });

            console.log(tagRes)

            /*await github.rest.repos.updateRelease({
              url: release.url,
              draft: false
            });*/

#          gh release --repo "${repo}" view 0.1.0 --json tagName -q '.tagName'
#
#          if ! gh release --repo "${repo}" edit --verify-tag; then
#            echo "::error title=GitHub Release::Please make sure to push the tag for the release."
#            exit 1
#          fi
